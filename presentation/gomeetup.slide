Gocrud
Go Meetup Brisbane
28 Sep 2015
Tags: go golang

Manish R Jain
Backend Developer
Ex-Googler - Web Search & Knowledge
manishrjain@gmail.com
https://mrjn.xyz
@manishrjain

* What is Gocrud?

Go framework to help build horizontally scalable and database-wise pluggable
CRUD-heavy backends from the get go.

* Why?

Because most startup founders have these concerns:

- Worry about MVP, not design and maintenance.
- Pick technology stack based on hype or convenience, not research.
- Little thought spent on horizontal scaling.
- Little thought spent on search engines to provide read-only access, or complex queries.
- Eager to sustain technical cancer (/debt).

* How does Gocrud help?

- Allows you to choose from a variety of data stores.
- No strict data schema, thanks to Graph like operations.
- Swap out one data store with another, with no code changes.
- Introduce search engines (like ElasticSearch) early on, to provide advanced search functionality.

* Design Principles

- *Versioning*: Keep track of all edits to the data. No blind overwriting.
- *Retention*: Retain all the edits, including deletion. Never _actually_ delete data, only mark it as deleted.
- *Authorship*: Always track who edited what.

* Use Case: Build a social platform
In a SQL / NoSQL table, this is how the data might be represented.

.image Plain.png

* Implement versioning to allow edits and reverts
Added a version field to all tables.

.image Version.png

* Implement retention to allow accountability
Added a deleted bit to all tables. As you can see, this gets complicated pretty fast.

.image Version_Delete.png

* Implement Authorship
Keep a separate log table to store all the edits to the data.

* Representation in Gocrud
As you can see, the SQL / NoSQL table approach gets pretty complicated, pretty fast.

Instead, Gocrud uses graph approach.

- Tables are considered entities, and all their properties and connections are edges.
- Edges are stored in an _append_only_ mode to data stores, as modifications happen.

.image social_graph.bmp

* Code: Updating data
.code example.go /^func storeUpdate/,/^}/

* Code: Querying data from store
.code example.go /^func storeQuery/,/^}/

* Code: Indexer for search engine
As Entities get modified in store, their corresponding search docs get re-generated and updated in search engine using *Indexers*.

.code example.go /SimpleIndexer/,/end_simple/

* Code: Query search engine
.code example.go /^func searchQuery/,/^}/
.code output.txt

* So what's the exit Strategy?

- I hate frameworks!
- Every framework should have a way to be abandoned.
- Create *store* and *search* modules, overwrite those functions with your custom implementation.
# Show the functions here.
